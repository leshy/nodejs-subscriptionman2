// Generated by CoffeeScript 1.9.3
(function() {
  var Backbone, Core, Validator, Validator2Matcher, _, async, asyncCallbackReturnMixin, basic, def, exists, fancy, helpers, objectMatcher, simplestMatcher, v,
    slice = [].slice;

  _ = require('underscore');

  async = require('async');

  Backbone = require('backbone4000');

  Validator = require('validator2-extras');

  v = Validator.v;

  helpers = require('helpers');

  Core = exports.Core = Backbone.Model.extend4000({
    initialize: function() {
      this.counter = 0;
      return this.subscriptions = {};
    },
    subscribeWait: function(timeout, pattern, callback, callbackError, name) {
      var errorTimeout, unsub, wrappedCallback;
      wrappedCallback = function() {
        var data;
        data = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        clearTimeout(errorTimeout);
        return callback.apply(this, data);
      };
      unsub = this.subscribeOnce(pattern, wrappedCallback, name);
      return errorTimeout = helpers.wait(timeout, function() {
        unsub();
        return helpers.cbc(callbackError, new Error('timeout'));
      });
    },
    subscribeOnce: function(pattern, callback, name) {
      var unsub, wrappedCallback;
      unsub = void 0;
      wrappedCallback = function() {
        var data;
        data = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        unsub();
        return callback.apply(this, data);
      };
      return unsub = this.subscribe(pattern, wrappedCallback, name);
    },
    subscribe: function(pattern, callback, name) {
      if (name == null) {
        name = this.counter++;
      }
      if (!callback && pattern.constructor === Function) {
        callback = pattern;
        pattern = true;
      }
      this.subscriptions[name] = {
        pattern: pattern,
        callback: callback
      };
      this.trigger('subscribe', name);
      return (function(_this) {
        return function() {
          delete _this.subscriptions[name];
          return _this.trigger('unsubscribe', name);
        };
      })(this);
    },
    event: function() {
      var data, eventType;
      data = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      eventType = _.first(data);
      async.filter(_.values(this.subscriptions), (function(_this) {
        return function(subscription, callback) {
          return _this.match(eventType, subscription.pattern, function(err, data) {
            return callback(!err);
          });
        };
      })(this), (function(_this) {
        return function(MatchedSubscriptions) {
          var next;
          if (_this.matchAll) {
            return _.map(MatchedSubscriptions, function(subscription, callback) {
              return subscription.callback.apply(this, data);
            });
          } else {
            next = function() {
              var sub;
              if (MatchedSubscriptions.length) {
                sub = MatchedSubscriptions.pop();
                return sub.callback.apply(this, data.concat(next));
              }
            };
            return next();
          }
        };
      })(this));
      if (data.length === 1) {
        return _.first(data);
      } else {
        return data;
      }
    }
  });

  asyncCallbackReturnMixin = exports.asyncCallbackReturnMixin = Backbone.Model.extend4000({
    eventAsync: function(value, data, callback) {
      if (!callback && data.constructor === Function) {
        callback = data;
        data = value;
      }
      return async.filter(_.values(this.subscriptions), (function(_this) {
        return function(subscription, callback) {
          return _this.match(value, subscription.pattern, function(err, data) {
            return callback(!err);
          });
        };
      })(this), (function(_this) {
        return function(MatchedSubscriptions) {
          return async.mapSeries(MatchedSubscriptions, function(subscription, callback) {
            return helpers.forceCallback(subscription.callback, data, callback);
          }, helpers.cb(callback));
        };
      })(this));
    }
  });

  simplestMatcher = exports.simplestMatcher = Backbone.Model.extend4000({
    match: function(value, pattern, callback) {
      if (value === pattern) {
        return callback(null, true);
      } else {
        return callback(true);
      }
    }
  });

  exists = exports.exists = true;

  objectMatcher = exports.objectMatcher = {
    match: function(value, pattern, callback) {
      if (pattern === exists) {
        return callback(void 0, true);
      }
      return !_.find(pattern, function(checkvalue, key) {
        if (!value[key]) {
          return callback(void 0, true);
        }
        if (checkvalue !== exists && value[key] !== checkvalue) {
          return callback(void 0, true);
        }
        return callback(true);
      });
    }
  };

  Validator2Matcher = exports.Validator2Matcher = {
    match: function(value, pattern, callback) {
      return pattern.feed(value, callback);
    },
    subscribe: function() {
      var attr;
      attr = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      attr[0] = v(attr[0]);
      return Core.prototype.subscribe.apply(this, attr);
    }
  };

  def = exports.def = Core.extend4000(simplestMatcher);

  basic = exports.basic = Core.extend4000(objectMatcher);

  fancy = exports.fancy = Core.extend4000(Validator2Matcher, asyncCallbackReturnMixin);

}).call(this);
